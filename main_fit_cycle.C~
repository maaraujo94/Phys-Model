////////////////////////////////////////////////////////////////////
// function that initializes fit values and performs the fitting  //
////////////////////////////////////////////////////////////////////

#include "TFitter.h"
#include "TMath.h"
#include "TROOT.h"
#include <fstream>
#include <iostream>
using namespace std;

#include "aux_func.C"
#include "aux_input.C"

vector <vector <double> > datasigma(10);

int ns[nstates] = {0};

//////////////////////////////////////
//part: the log-likelihood function
/////////////////////////////////////

//defining the log-likelihood
double myFunction(double Ljpsi, double Lups1, double A, double beta, double tau, double rho, double delta, double b, double c, double d, double e, double brjpsidm, double brups1dm, double lcms, double latlas, double llhcbpsi, double llhcbups, double ptmmin)
{
  double xinorm = 4, ssnorm = 7000, ynorm = 0, Mnorm = mass[0], loglike = 0.;
  int pos = 0, stateid;

  //defining the arguments of sig()
  double pars[14] = {ssnorm/Mnorm, xinorm, ynorm, A, beta, tau, rho, delta, 1., Mnorm, b, c, d, e};
  //normalize all states at xinorm, ynorm
  double signc = sig(pars);

  //store all state-specific parameters here
  double Mstate[nstates] = {mass[0], mass[0], mass[0], mass[0], mass[0], mass[0], mass[4], mass[4], mass[4], mass[4], mass[4], mass[4], mass[4], mass[4]};
  double Lstate[nstates] = {Ljpsi, Ljpsi, Ljpsi, Ljpsi, Ljpsi, Ljpsi, Lups1, Lups1, Lups1, Lups1, Lups1, Lups1, Lups1, Lups1};
  double lumistate[nstates] = {lcms, llhcbpsi, llhcbpsi, llhcbpsi, llhcbpsi, llhcbpsi, lcms, latlas, latlas, llhcbups, llhcbups, llhcbups, llhcbups, llhcbups};
  double BRstate[nstates] = {brjpsidm, 1, 1, 1, 1, 1, brups1dm, brups1dm, brups1dm, brups1dm, brups1dm, brups1dm, brups1dm, brups1dm};

  //cycle for cross section measurements
  for(int stateid = 0; stateid < nstates; stateid++)
    if(ns[stateid] != 0) {
      loglike += statecont(datasigma, pars, signc, ptmmin, Mstate[stateid], Lstate[stateid], lumistate[stateid], BRstate[stateid], pos, ns[stateid]);
      pos += ns[stateid];
    }
  
  //constraints for the BR nuisance parameters
  loglike -= 0.5*((brjpsidm-1)/(0.033/5.961))*((brjpsidm-1)/(0.033/5.961));
  loglike -= 0.5*((brups1dm-1)/(0.05/2.48))*((brups1dm-1)/(0.05/2.48));
  
  //constraints for the luminosity nuisance parameters
  loglike -= 0.5*((lcms-1)/2.2e-2)*((lcms-1)/2.2e-2);
  loglike -= 0.5*((latlas-1)/3.9e-2)*((latlas-1)/3.9e-2);
  loglike -= 0.5*((llhcbpsi-1)/3.5e-2)*((llhcbpsi-1)/3.5e-2);
  loglike -= 0.5*((llhcbups-1)/1.7e-2)*((llhcbups-1)/1.7e-2);
  
  //I am returning the chisquare because I can't figure out how to change the fit method (must check this)
  return -2*loglike;
}

//Minuit-specific "wrapping"
void minuitFunction(int& nDim, double* gout, double& result, double par[], int flg)
{
  result = myFunction(par[0], par[1], par[2], par[3], par[4], par[5], par[6], par[7], par[8], par[9], par[10], par[11], par[12], par[13], par[14], par[15], par[16], par[17]);
}

//main function: collects data, does the fit, plots the results
void fit()
{
  //define variables
  
  ofstream outf;
  ofstream fitf;
  int ndf, aux_int = 0, len[2] = {0};
  
  double param[nparam], ptmmin = 0., chisquare, L_est[2];
  float PTMNORM = 4.;
  
  //////////////////////////////////
  //part: getting data from files
  /////////////////////////////////

  input(datasigma, ns);

  for(int i = 0; i < nstates; i++)
    cout << ns[i] << " ";
  cout << endl;
  
  ////////////////////////////
  //part: fitting the data
  ///////////////////////////

  //calculate estimates for L_QQ
  for(int i = 0; i < 6; i++) len[0] += ns[i];
  for(int i = 6; i < 14; i++) len[1] += ns[i];
  for(int i = 0; i < 2; i++) {
    L_est[i] = lest(datasigma, PTMNORM, aux_int, len[i]);
    aux_int += len[i];
  }

  const int n_tau = 7, n_s = 3, n_L = 3;
  double tau_init[n_tau] = {0, 0.33, 0.67, 1, 1.33, 1.67, 2};
  //double s_init[n_s] = {1, 2, 3};
  //double L_init[n_L] = {10, 100, 1000};
  
  //define function to minimize, set initial parameters
  //TFitter* fit = new TFitter(nparam+1);
  //fit->SetFCN(minuitFunction);

  int status;
  outf.open("vars_res.txt");
  outf << "L   tau   chisquare, ndf   status" << endl;

  for(int iL = 0; iL < n_L; iL++)
    for(int ibeta= 0; ibeta < n_s; ibeta++)
      for(int irho = 0; irho < n_s; irho++)
	for(int ib = 0; ib < n_s; ib++)
	  for(int itau = 0; itau < n_tau; itau++)
	    {
	      TFitter* fit = new TFitter(nparam+1);
	      fit->SetFCN(minuitFunction);
      
	      aux_int = 0;
	      fit->SetParameter(aux_int, "L_jpsi", L_est[0], L_est[0]/10, 0, 0);
	      fit->FixParameter(aux_int);
	      aux_int++;
	      fit->SetParameter(aux_int, "L_ups1", L_est[1]*L_init[iL], L_est[1]*L_init[iL]/10, 0, 0);
	      //fit->FixParameter(aux_int);
	      aux_int++;
	    
	      fit->SetParameter(aux_int, "A", 0, 0.1, 0, 0);
	      fit->FixParameter(aux_int);
	      aux_int++;
	      fit->SetParameter(aux_int, "beta", s_init[ibeta], 0.1, 0, 0);
	      //fit->FixParameter(aux_int);
	      aux_int++;
	      fit->SetParameter(aux_int, "tau", tau_init[itau], 0.1, 0, 0);
	      fit->FixParameter(aux_int);
	      aux_int++;
	      fit->SetParameter(aux_int, "rho", s_init[irho], 0.1, 0, 0);
	      //fit->FixParameter(aux_int);
	      aux_int++;
	      fit->SetParameter(aux_int, "delta", 0, 0.1, 0, 0);
	      fit->FixParameter(aux_int);
	      aux_int++;
	      
	      fit->SetParameter(aux_int, "b", s_init[ib], 0.1, 0, 0);
	      //fit->FixParameter(aux_int);
	      aux_int++;
	      fit->SetParameter(aux_int, "c", 6, 1., 0, 0);
	      fit->FixParameter(aux_int);
	      aux_int++;
	      fit->SetParameter(aux_int, "d", 0., 0.1, 0, 0);
	      fit->FixParameter(aux_int);
	      aux_int++;
	      fit->SetParameter(aux_int, "e", 0., 0.1, 0, 0);
	      fit->FixParameter(aux_int);
	      aux_int++;
	      
	      fit->SetParameter(aux_int, "br_jpsi_dm", 1., 0.01, 0, 0);
	      fit->FixParameter(aux_int);
	      aux_int++;
	      fit->SetParameter(aux_int, "br_ups1_dm", 1, 0.01, 0, 0);
	      fit->FixParameter(aux_int);
	      aux_int++;
	      
	      fit->SetParameter(aux_int, "L_CMS", 1, 0.1, 0, 0);
	      fit->FixParameter(aux_int);
	      aux_int++;
	      fit->SetParameter(aux_int, "L_ATLAS", 1, 0.1, 0, 0);
	      fit->FixParameter(aux_int);
	      aux_int++;
	      fit->SetParameter(aux_int, "L_LHCb_psi", 1, 0.1, 0, 0);
	      fit->FixParameter(aux_int);
	      aux_int++;
	      fit->SetParameter(aux_int, "L_LHCb_ups", 1, 0.1, 0, 0);
	      fit->FixParameter(aux_int);
	      aux_int++;
	      
	      fit->SetParameter(aux_int, "ptm_min", ptmmin, 1, 0, 0);
	      fit->FixParameter(aux_int);
	      
	      //set aux_int to nr of nuisance params (2+4)
	      aux_int = 0;
      
	      status = fit->ExecuteCommand("MIGRAD",0,0);
      
	      //////////////////////////////
	      // part: storing fit results
	      //////////////////////////////
      
	      //register the fit parameters to an array
	      for(int i = 0; i < nparam; i++)
		param[i] = fit->GetParameter(i);
      
	      chisquare = myFunction(param[0], param[1], param[2], param[3], param[4], param[5], param[6], param[7], param[8], param[9], param[10], param[11], param[12], param[13], param[14], param[15], param[16], ptmmin);
	      
	      ndf = 0;
	      //calculating the number of data points used in the fit
	      for(int i = 0; i < (int)datasigma[0].size(); i++)
		{
		  if(datasigma[0][i] >= ptmmin)
		    ndf += 1;
		}
	      //cout << ndf << " data points" << endl;
	      //I am adding one degree of freedom for each of the nuisance parameters
	      ndf += aux_int;
	      //the final ndf is obtained by subtracting the number of free parameters
	      ndf -= fit->GetNumberFreeParameters();
	      //cout << "ndf " << ndf << endl;
	      
	      //cout << "chi^2 norm : " << chisquare/ndf  << endl;
	      //  cout << "chi^2 prob : " << TMath::Prob(chisquare,ndf)  << endl;
      
	      outf << L_init[iL] << "   " << s_init[ibeta] << "   " << s_init[irho] << "   " << s_init[ib] << "   " << tau_init[itau] << "   ";
	      outf << chisquare << ", " << ndf << "   " << status << endl;

	      string savename = Form("fit_cycle/fit_%d%d%d%d%d.txt", iL, ibeta, irho, ib, itau); 
	      fitf.open(savename);
	      for(int i = 0; i < nparam; i++)
		fitf << param[i] << " ";
	      for(int i = 0; i < nparam; i++)
		fitf << fit->GetParError(i) << " ";
	      fitf << ptmmin << " ";
	      fitf << chisquare << " " << ndf << endl;
	      fitf.close();
	    }
  outf.close();
  
  //////////////////////////////////////
  //part: saving results to an outfile
  //////////////////////////////////////
  
  

}
